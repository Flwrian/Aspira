package com.example;

import java.io.IOException;
import java.io.FileWriter;
import java.util.Arrays;
import java.util.Scanner;
import java.util.Map;
import java.util.HashMap;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;


import com.bitboard.BitBoard;
import com.bitboard.Move;
import com.bitboard.Perft;




public class CompareWithStockFish {
    
    // We will use perft to compare the number of nodes generated by our engine with the number of nodes generated by StockFish.
    // We will use the same position and depth to compare the results.
    
    public static String stockfish_location = ".//engines//stockfish//stockfish.exe";

    public static Stockfish stockfish = new Stockfish();


    public String compareWithStockFish(int depth, BitBoard bitBoard) {
        StringBuilder result = new StringBuilder();

        String fen = bitBoard.getFen();
        result.append("FEN: ").append(fen).append("\n");
    
    
        // Lancer le perft de ton moteur
        long startTime = System.currentTimeMillis();
        String perfString = Perft.perftDivideString(bitBoard, depth);
        long endTime = System.currentTimeMillis();
        result.append("=== Flowgine Perft Results ===\n");
        result.append("[ " + (endTime - startTime) + " ms ]\n");
        result.append(perfString).append("\n");
    
        // Lancer le moteur StockFish
        stockfish.startEngine();
        stockfish.sendCommand("position fen " + bitBoard.getFen());
        stockfish.sendCommand("go perft " + depth);
        String stockFishOutput = stockfish.getOutput(0);
        result.append("=== StockFish Perft Results ===\n");
        result.append(stockFishOutput).append("\n");
        stockfish.stopEngine();
    
        // Comparaison des résultats
        String[] perfStringLines = perfString.split("\n");
        String[] stockFishOutputLines = stockFishOutput.split("\n");
    
        // Ignorer les 3 premières lignes de debug
        perfStringLines = Arrays.copyOfRange(perfStringLines, 3, perfStringLines.length);
        stockFishOutputLines = Arrays.copyOfRange(stockFishOutputLines, 3, stockFishOutputLines.length);

        int totalNodesOur = Integer.parseInt(perfStringLines[perfStringLines.length - 1].split(": ")[1]);
        int totalNodesSF = Integer.parseInt(stockFishOutputLines[stockFishOutputLines.length - 1].split(": ")[1]);

        // remove the last line
        perfStringLines = Arrays.copyOfRange(perfStringLines, 0, perfStringLines.length - 1);
        stockFishOutputLines = Arrays.copyOfRange(stockFishOutputLines, 0, stockFishOutputLines.length - 1);

    
        // Trier les résultats pour une comparaison simple
        perfStringLines = Arrays.stream(perfStringLines).sorted().toArray(String[]::new);
        stockFishOutputLines = Arrays.stream(stockFishOutputLines).sorted().toArray(String[]::new);
    
        // Comparaison ligne par ligne
        result.append("\n=== Comparison of Individual Move Nodes ===\n");
        result.append("[ - Depth: ").append(depth).append(" - ]\n");
        for (int i = 0; i < Math.max(perfStringLines.length, stockFishOutputLines.length); i++) {
            try {
                String[] perfStringLine = perfStringLines[i].split(": ");
                String[] stockFishOutputLine = stockFishOutputLines[i].split(": ");
    
                if (perfStringLine[1].equals(stockFishOutputLine[1])) {
                    result.append(String.format("[v] Flowgine: %s - %s | StockFish: %s - %s%n",
                            perfStringLine[0], perfStringLine[1], stockFishOutputLine[0], stockFishOutputLine[1]));
                } else {
                    result.append("--------------------\n[x] Invalid number of nodes: \n");
                    result.append(String.format("Flowgine: %s - %s%n", perfStringLine[0], perfStringLine[1]));
                    result.append(String.format("StockFish: %s - %s%n", stockFishOutputLine[0], stockFishOutputLine[1]));
                    result.append("--------------------\n");
                }
            } catch (ArrayIndexOutOfBoundsException e) {
                continue;
            }
        }
    
        // Comparaison des noeuds totaux
        result.append("\n=== Total Nodes Comparison ===\n");
        try {
    
            if (totalNodesSF == totalNodesOur) {
                result.append("[*V*] Valid total nodes: ").append(totalNodesOur).append("\n");
            } else {
                result.append("[**X**] Invalid total nodes:\n");
                result.append("Flowgine: ").append(totalNodesOur).append("\n");
                result.append("StockFish: ").append(totalNodesSF).append("\n");
            }
        } catch (Exception e) {
            result.append("[!] Error in total nodes comparison.\n");
        }
    
        // Écrire les résultats dans un fichier avec commé clé le depth et le timestamp
        long timestamp = System.currentTimeMillis();
        String fileName = "./perft-results/perft_comparison_results-" + depth + "-" + timestamp + ".txt";
        try {
            FileWriter writer = new FileWriter(fileName);
            writer.write(result.toString());
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        return fileName;
    }

    public static void analyzeErrors(String filename) {
        // Nous allons créer une fonction pour analyser les erreurs dans les résultats de la comparaison et recréer les positions problématiques pour les analyser.

        // File example :
        //         === Flowgine Perft Results ===
        // [PerftDivide]
        // [Depth: 5]
        // [x]
        // h2h3: 181044
        // h2h4: 218810
        // g2g3: 217210
        // g2g4: 214013
        // f2f3: 178889
        // f2f4: 198435
        // e2e3: 402988
        // e2e4: 405348
        // d2d3: 328511
        // d2d4: 361753
        // c2c3: 222861
        // c2c4: 240044
        // b2b3: 215255
        // b2b4: 216110
        // a2a3: 181046
        // a2a4: 217813
        // g1h3: 198502
        // g1f3: 233491
        // b1c3: 234656
        // b1a3: 198572

        // Nodes searched: 4865351

        // === StockFish Perft Results ===
        // Stockfish 16.1 by the Stockfish developers (see AUTHORS file)
        // info string NNUE evaluation using nn-baff1ede1f90.nnue
        // info string NNUE evaluation using nn-b1a57edbea57.nnue
        // a2a3: 181046
        // b2b3: 215255
        // c2c3: 222861
        // d2d3: 328511
        // e2e3: 402988
        // f2f3: 178889
        // g2g3: 217210
        // h2h3: 181044
        // a2a4: 217832
        // b2b4: 216145
        // c2c4: 240082
        // d2d4: 361790
        // e2e4: 405385
        // f2f4: 198473
        // g2g4: 214048
        // h2h4: 218829
        // b1a3: 198572
        // b1c3: 234656
        // g1f3: 233491
        // g1h3: 198502

        // Nodes searched: 4865609



        // === Comparison of Individual Move Nodes ===
        // [ - Depth: 5 - ]
        // --------------------
        // [x] Invalid number of nodes: 
        // Flowgine: Nodes searched - 4865351
        // StockFish: Nodes searched - 4865609
        // --------------------
        // [v] Flowgine: a2a3 - 181046 | StockFish: a2a3 - 181046
        // --------------------
        // [x] Invalid number of nodes: 
        // Flowgine: a2a4 - 217813
        // StockFish: a2a4 - 217832
        // --------------------
        // [v] Flowgine: b1a3 - 198572 | StockFish: b1a3 - 198572
        // [v] Flowgine: b1c3 - 234656 | StockFish: b1c3 - 234656
        // [v] Flowgine: b2b3 - 215255 | StockFish: b2b3 - 215255
        // --------------------
        // [x] Invalid number of nodes: 
        // Flowgine: b2b4 - 216110
        // StockFish: b2b4 - 216145
        // --------------------
        // [v] Flowgine: c2c3 - 222861 | StockFish: c2c3 - 222861
        // --------------------
        // [x] Invalid number of nodes: 
        // Flowgine: c2c4 - 240044
        // StockFish: c2c4 - 240082
        // --------------------
        // [v] Flowgine: d2d3 - 328511 | StockFish: d2d3 - 328511
        // --------------------
        // [x] Invalid number of nodes: 
        // Flowgine: d2d4 - 361753
        // StockFish: d2d4 - 361790
        // --------------------
        // [v] Flowgine: e2e3 - 402988 | StockFish: e2e3 - 402988
        // --------------------
        // [x] Invalid number of nodes: 
        // Flowgine: e2e4 - 405348
        // StockFish: e2e4 - 405385
        // --------------------
        // [v] Flowgine: f2f3 - 178889 | StockFish: f2f3 - 178889
        // --------------------
        // [x] Invalid number of nodes: 
        // Flowgine: f2f4 - 198435
        // StockFish: f2f4 - 198473
        // --------------------
        // [v] Flowgine: g1f3 - 233491 | StockFish: g1f3 - 233491
        // [v] Flowgine: g1h3 - 198502 | StockFish: g1h3 - 198502
        // [v] Flowgine: g2g3 - 217210 | StockFish: g2g3 - 217210
        // --------------------
        // [x] Invalid number of nodes: 
        // Flowgine: g2g4 - 214013
        // StockFish: g2g4 - 214048
        // --------------------
        // [v] Flowgine: h2h3 - 181044 | StockFish: h2h3 - 181044
        // --------------------
        // [x] Invalid number of nodes: 
        // Flowgine: h2h4 - 218810
        // StockFish: h2h4 - 218829
        // --------------------

        // === Total Nodes Comparison ===
        // [**X**] Invalid total nodes:
        // Flowgine: 4865351
        // StockFish: 4865609

        int depth = 0;


        // On repère les lignes qui contiennent [x] et on recrée les positions problématiques pour les analyser ([x] Invalid number of nodes, n'est pas un "coup", c'est la ligne au dessous juste après "Flowgine:")

        try {
            BufferedReader reader = new BufferedReader(new FileReader(filename));
            String line;
            ArrayList<String> problematicPositions = new ArrayList<>();
            while ((line = reader.readLine()) != null) {
                // check for depth
                if (line.startsWith("[Depth:")) {
                    depth = Integer.parseInt(line.split(": ")[1].split("]")[0]);
                }
                if (line.startsWith("Flowgine:")) {
                    String[] parts = line.split(" - ");
                    String position = parts[0].split(": ")[1];
                    // if the position is an int then it's a total nodes line so we skip it
                    if (position.matches("\\d+")) {
                        continue;
                    }
                    problematicPositions.add(position);
                }
            }
            reader.close();

            // Maintenant que l'on a les positions problématiques, on va faire un perft sur ces positions pour les analyser puis refaire l'analyse des résultats. A chaque fois la profondeur sera diminuera de 1 pour voir si on peut trouver la position problématique.

            for (String position : problematicPositions) {
                BitBoard bitBoard = new BitBoard();
                bitBoard.loadFromFen("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
                bitBoard.makeMove(position);
                
            }

        } catch (IOException e) {
            e.printStackTrace();
        }

            
    }


    public static void main(String[] args) {
        if (args.length > 0) {
            analyzeErrors(args[0]);
            return;
        }
        Stockfish.setPATH(stockfish_location);
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter the depth for the perft comparison: ");
        int depth = scanner.nextInt();
        scanner.close();

        BitBoard bitBoard = new BitBoard();
        
        // bitBoard.loadFromFen("r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq - 0 1");

        bitBoard.makeMove("c2c3");
        bitBoard.makeMove("e7e6");
        
        bitBoard.printChessBoard();
        CompareWithStockFish compareWithStockFish = new CompareWithStockFish();
        compareWithStockFish.compareWithStockFish(depth, bitBoard);

    }
    
}
